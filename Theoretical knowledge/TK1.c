#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>//stdio.h是一个标准输入输出头文件 #include用于引入头文件
#include <stddef.h>
/*提供了常用类型：
size_t：这是一个无符号整数类型，通常用于表示对象的大小（如数组的大小或内存分配的字节数）。许多标准库函数（如 malloc、strlen）的参数或返回值使用 size_t。
ptrdiff_t：这是一个带符号整数类型，用于表示两个指针之间的差值，通常用于循环和指针运算的场景。
提供了两个宏：
NULL：它是一个常量，用于表示空指针，虽然在 <stdio.h> 中也可以找到，但将其定义在 <stddef.h> 中是为了提高代码的可读性。
offsetof：宏函数，用于确定结构的某个成员到起始位置的偏移字节*/

//标准输入输出函数
//int main()//int 表示函数的返回值类型；所有的c语言程序都要包括main（）函数；c语言规定main函数是程序的入口,表示执行的起点。
//{
	//打印字符串
	//printf("Hello Zejun\n");//字符串面值或常量是括在双引号""中，而字符常量是括在单引号''中;特别的，空格也是字符
	//字符串的结束标志是空字符'\0'(一个转义字符），它不占用内存空间，一般隐藏在字符串的末尾，无需特别处理。

	//计算字数据类型的字节数
	//printf("%zu\n", sizeof(char)); //printf()函数是一个库函数，用于输出字符串到控制台；库函数的使用必须引入头文件。
	//printf("%zu\n", sizeof(int));//sizeof()函数用于计算变量或数据类型的字节数，而strlen()函数用于计算字符串的长度。
	//printf("%zu\n", sizeof(short));
	//printf("%zu\n", sizeof(float));
	//printf("%zu\n", sizeof(double));
	//printf("%zu\n", sizeof(long));
	//printf("%zu\n", sizeof(long long));

	//system("pause"); //system()用于运行系统命令，但仅限于Windows系统。pause函数表示让进程暂停直到信号出现
	//return 0;//return 0 可表示执行成功
//}

/*转义字符：将打印字符变为特殊含义的字符，如\n表示换行符、\t表示制表符、\b表示退格符、\r表示回车符等。如果要打印真正的反斜杠字符，则需要用两个反斜杠表示，如\\表示一个反斜杠。此外，转义字符算作一个字符，如\t的长度为1。*/

/*数据类型包括
char字符数据型
int整型数据型。字符本质上也是整型
short短整型数据型
float浮点型数据型
double双精度浮点型数据型
long长整型数据类型
long long更长的长整型数据型*/

//运算符演示
//int main()
//{
//	float a = 7 / 2.0;//除号两端都是整数，结果为整数，需要加.0来表示浮点数
//	printf("%.2f\n", a);//保留两位小数
//	int b = 10 % 3;//取模操作符的两端都必须是整数
//	printf("%d\n", b);
//	return 0;
//}

//运算符
//int main()//算术运算符（+、-、*、/、%）与赋值运算符（=、+=、-=、*=、/=、%=）
//{ 
	//int a = 0;//初始化
	//a = 10;//赋值
	//a += 10;//a = a + 10;
	//a -= 5;//a = a - 5;以此类推
	//int b = 0;
	//b = a++;//先赋值，再运算
	//printf("%d\n", a);
	//输出结果为b=10，a=15；a--同理
	//b = ++a;//先运算，再赋值
	//printf("%d\n", b);
	//printf("%d\n", a);
	//输出结果为b=16，a=16；--a同理
	//int c = (int) 3.14;//强制类型转换
	//printf("%d\n", c);//输出结果为3
//}

//关系运算符包括==、!=、<、>、<=、>=
//逻辑运算符包括&&（与）、||（或）、!（非）
//单目运算符包括++（自增）、--（自减）、+（正号）、-（负号）、*（指针）、&（取地址）、sizeof（取字节数）
//条件运算符也称为三目运算符，即条件表达式 ?  : ，它根据条件表达式的值（真或假）来决定表达式的值。
/*int main()
{
	int a = 0;
	int b = 0;
	int c = 0;
	scanf("%d%d", &a, &b);
	c = a > b ? a : b;//按a和b的顺序填表达式就行了；可用于比较两个数的大小
	printf("%d\n", c);
	//逗号表达式，即将多个表达式用逗号隔开，特点是从左到右计算，并返回最后一个表达式的值。
	int d = (c = a + b, b = c + a, b + c);
	printf("%d\n", d);
}*/
/*3) 条件运算符的嵌套：
int max = (a > b ? a : (b > c ? b : c));在这个例子中，条件运算符的嵌套从右到左进行评估。首先评估 b > c，如果这个条件为真，则返回 b，否则返回 c。然后再将得到的结果与 a 进行比较，最终得到 max 的值。即先运算最里层的条件表达式。*/

//&&运算符：左右两边的表达式都为真，则结果为真；否则结果为假。即布尔逻辑中的and运算。
//||运算符：左右两边的表达式有一个为真，则结果为真；否则结果为假。即布尔逻辑中的or运算。
//!运算符：取反，即表达式为真则结果为假，表达式为假则结果为真。即布尔逻辑中的not运算。
//?:运算符：条件运算符，即if-else语句的简化形式。

/*函数：
1.维基百科的定义为：子程序，是一个大型程序中的某部分代码，由一个或者多个语句块组成。它负责完成特定的功能，而且相较于其他代码，具备独立性
2.一般会有输入参数并有返回值，提高对过程的封装的细节的隐藏，这些代码通常被集成软件库
3.函数分为库函数和自定义函数
4.函数的实参（实际参数）是指在函数调用时传递给函数的具体值或变量。实参可以是常量、变量、表达式或其他函数的返回值。当函数被调用时，实参的值会被传递给相应的形参（形式参数），帮助函数完成其任务
5.形参只有在函数调用时才实例化（分配内存单元），当函数结束之后就自动销毁了。因此形参只在函数内有效*/
//因为数组的不可复制性，所以无法编写数组类型的形参；数组名会自动转化为指针。

//设计的函数尽量单一，不与其他函数产生太多联系，即遵循“高内聚，低耦合”原则。如上面的判断函数，只执行判断功能，要使用的时候调用就可以了，打印的工作放在main函数里。
//如果耦合度过高（产生了太多关联），意味着一个函数出错就会牵连到其他更多的函数，需要排错修改的时间成本大大增加（除非你能确定写完之后绝对不用修改了）

//函数的返回值需要根据实际情况决定，如用二分法寻找有序数组中某个数时，若“找到了”就返回数的下标，则“找不到”的返回值不能设置为0，因为数组中第一个数的下标就是0。这时可以把“找不到”的返回值设置成 -1。

//数组传参实际上传的是一个指针变量（首个元素的地址），外部函数调用该数组的数时通过这个指针来访问。

// n++ 是后置++，如果写return n++，则先返回n的值再给n+1。

//使用指针可以在函数中修改实参的值。如：
//void swap(int *x, int *y)
//{
//	int temp = *x;
//	*x = *y;
//	*y = temp;
//}
//int main()
//{
//	int a = 10, b = 20;
//	printf("Before swap: a = %d, b = %d\n", a, b);
//	swap(&a, &b);//调用时要用&传递地址，告诉外部函数要访问哪里。
//	printf("After swap: a = %d, b = %d\n", a, b);
//	return 0;
//}

/*函数调用分为两种
1.传值调用：在传值调用的过程中，形参只是局部变量，其初值直接使用函数括号内实参的值，运行时占另外的空间，不对实参造成影响
2.传址调用：在传址调用的过程中，形参和实参占用同一内存单元，因此在函数内对形参的修改会影响实参的值，使得函数内部可以直接操作函数外部的变量*/

#include <string.h>//string.h中提供了一些字符串处理函数，如strcpy()，strcmp(),strlen()等。
//不使用临时变量，计算字符长度。解释：
//int my_strlen(char *str)//用指针接收地址；也可以写成数组的形式，如str[]。
//{
//	int count = 0;//为了实现某个功能（比如这里的计数）而创建，用完就销毁的变量（局部变量），称为临时变量
//	while (*str != '\0')
//	{
//		count++;
//		str++;//直接使用++找下一个字符。注意，是str而不是*str。
//	}
//	return count;
//}
//实现：
//int my_strlen(char *str)
//{
//	if (*str != '\0')
//	{
//		return 1 + my_strlen(str + 1);//参数里不能写str++。使用str + 1是正确的做法，因为它只是计算出下一个字符的地址，而不改变str指针本身。这样，str在每次递归调用中仍然指向原始字符串的起始地址。
//	}
//	else
//		return 0;
//}
//int main()
//{
//  //printf("%d\n", my_strlen("abc"));
//	char arr[4] = "abc";
//	printf("%d\n", my_strlen(arr));//字符串和数组的元素都是连续存放的，因此它们传参都是传首元素的地址，通过这个地址就可以访问到首元素及其后面的各个元素。
//	return 0;
//}

//最好能有一个自己的代码库，这样想要实现什么相似的功能直接复制粘贴就可以了。

//链式访问：把一个函数的返回值作为另一个函数的参数。


//递归函数：1.要有可以结束递归的限制条件 2.每次执行之后越来越接近这个限制条件
//int Fact(int n)
//{
//	int ret = n;
//	if (n > 1)
//	{
//		ret *= Fact(n - 1);
//	}
//	return ret;//执行完最后一个函数后会返回上一个函数（用调试可以看到ret的值并非直接返回main函数而是上一个Fact函数）。 即“从哪来从哪回去！”。
//}
// int main()
//{
//	int n = 0;
//  int i = 1;
//	int ret = 1;
//	scanf("%d", &n);
//	for (i = 1; i <= n; i++)
//	{
//		ret *= i;
//	}
//  printf("%d\n", ret);
//  printf("%d\n", Fact(n));
//	return 0;
//}
//复杂函数：如果函数里有很多复杂的代码和逻辑，定义成内联函数会导致代码变得很长，增加可执行文件的大小，并且可能降低执行效率。 递归函数：递归函数是自己调用自己，定义成内联函数会导致无限展开，编译器无法正确处理。
//递归函数缺点：1.时间复杂度高 2.递归层数越深，栈内存占用越大，越容易发生栈溢出易。
/*当循环条件任意找到时，应该避免使用递归。
* 例如上述代码段，只需要新增一个变量i，将递归里需要栈区保存的数据交给程序自身来保存，就能完成递归向非递归的转化了
如果问题过于复杂，直接用非递归一时半会想不出来解决的算法，而且用递归解决要消耗过多的堆栈，或者问题规定了要用非递归来解决，那么可以先将问题用递归的大事化小的思维解出来递归算法，再然后将递归算法转化为非递归算法即可。*/

/*“递归里需要栈区保持的数据交给程序自身来保存”指的是将递归过程中需要存储的状态信息用变量在外层函数中保存，而不是利用系统的调用栈来维护这些状态。
在递归过程中，每次函数调用都会占用栈空间，用于保存局部变量和返回地址。*/

/*数组是 C 语言中一种用于存储多个同类型数据的集合。它可以看作是一个固定大小的连续内存区域，允许通过索引来访问和操作其中的元素。
数组传参可以写成指针传参和数组名传参两种形式。数组名传参本质上是传了首元素的地址（1），而地址要用指针来接收，所以看似写了个数组在括号里，实际上那是一个指针变量。
因而不可以在外部函数求出数组的长度，应该先求好再传给外部函数。（参考storage box中的冒泡排序）

（1）有两个例外：sizeof(arr)里的数组名表示整个数组的大小；&数组名，取出的是整个数组的地址*/

//逆序打印数组元素：
//int main()
//{
//	int are [] = {1,2,3,4,5,6,7,8,9,10};
//	int sz =sizeof(are)/sizeof(0);//总字节大小除以某一个元素字节大小，得到数组元素个数;sizeof是一个操作符，不需要引入头文件即可使用。这里的结果是sz = 10。
//	int i = 0;
//	for (i = sz - 1; i >= 0; i--)
//	{
//		printf("%d ", are[i]);//这里的[]是引用下标操作符
//	}
//	return 0;
//}

//二维数组的初始化：
//int main()
//{
//	int arr1[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };//两个[]分别表示行数和列数
//	int arr2[ ][4] = { 1,2,3,4,5,6,7,8 };//可以省略行数,但列不能省略
//	int arr3[3][4] = { {1,2},{3,4},{5,6} };//可以用花括号将各行元素括起来
//	//用调试->监视窗口可直接看到数组里存放的元素。
//	return 0;
//}
//二维数组每一行都可以看作是一个一维数组；二维数组的数组名也是首元素的地址，传参传的是第一行的地址。
//计算二维数组的行和列数：
//int main()
//{
//	int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
//	int rows = sizeof(arr) / sizeof(arr[0]);//行数
//	int cols = sizeof(arr[0]) / sizeof(arr[0][0]);//列数
//	printf("rows = %d, cols = %d\n", rows, cols);
//	return 0;
//}

//出现乱码（昆拷斤烫烫烫）的原因：电脑根据标识符的二进制编号来查找并显示字符的，同一个编号在不同编码方式里代表的字符不同，造成了乱码。
//比如编译器用的是UTF-8，而记事本默认的编码方式是GBK，用编译器编完然后用记事本打开，就会出现昆拷斤烫烫烫的情况。