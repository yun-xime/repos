#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//数组越界与覆盖
//栈区的使用习惯是先使用高地址处的空间，然后再使用低地址处的空间
//数组随着下标增长，地址由低到高变化
//两者的地址空间是相邻的，所以数组的越界与覆盖问题也就随之而来。
//在一些编译器中，这种错误不会报出来，可以通过调试器来查看。如：a[i] = 0, i > n, 数组a的长度为n,调试时取&a[i],&i,发现两者的地址相同，即修改a[i]的值，也会影响到i的值。
//(在本编译器中会直接报错，提示数组越界)
// 
//int main()
//{
//    int a[5] = { 1,2,3,4,5 };
//    int i = 5;
//    a[i] = 0; //数组越界
//    return 0;
//}  

/*优秀的代码：
1.代码在各平台上都能正常运行（即可移植性强）
2.代码易读易懂，命名规范，注释清晰
3.可维护性强，修改方便，易于扩展
4.文档齐全*/

//void strcpy(char* dst, const char* src)//const修饰src，表示src指向的字符串内容不可修改（起到保护作用），避免写代码的时候脑子一昏把要复制的数组和要覆盖的数组搞混。
//{
//    while (*src != '\0')
//    {
//        *dst = *src;
//        dst++;
//        src++;
//    }
//    *dst = '\0';
//}

//int main()
//{
//	const int n = 5;
//	/*int* p = &n;
//	*p = 10;*/ //可以用指针修改变量的值
//
//	//1.
//	const int* p = &n;
//	/**p = 10; *///报错。意思是指针p指向的地址不能修改，但指针本身可以修改。
//
//	//如：
//	int num = 2233;
//	//*p = &num;//error
//	p = &num; //right
//
//	//2.
//	int* const q = &num;
//	*q = 100; //right
//	//q = &num; //error。情况与1.相反。
//
//	return 0;
//}