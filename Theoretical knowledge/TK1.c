#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>//stdio.h是一个标准输入输出头文件 #include用于引入头文件
#include <stddef.h>
/*提供了常用类型：
size_t：这是一个无符号整数类型，通常用于表示对象的大小（如数组的大小或内存分配的字节数）。许多标准库函数（如 malloc、strlen）的参数或返回值使用 size_t。
ptrdiff_t：这是一个带符号整数类型，用于表示两个指针之间的差值，通常用于循环和指针运算的场景。
提供了两个宏：
NULL：它是一个常量，用于表示空指针，虽然在 <stdio.h> 中也可以找到，但将其定义在 <stddef.h> 中是为了提高代码的可读性。
offsetof：宏函数，用于确定结构的某个成员到起始位置的偏移字节*/

//打印数组元素
//int are [9] = {1,2,3,4,5,6,7,8,9};//数组是 C 语言中一种用于存储多个同类型数据的集合。它可以看作是一个固定大小的连续内存区域，允许通过索引来访问和操作其中的元素。
//int daying()//函数声明
//{
//	int i=0;
//	while (i < 9)
//	{
//		printf("%d ", are[i]);//printf()函数是一个库函数，用于输出字符串到控制台；库函数的使用必须引入头文件。
//		i++;
//	}
//  printf("%d\n",sizeof(are)/sizeof(0));//总字节大小除以某一个元素字节大小，得到数组元素个数;sizeof是一个操作符，不需要引入头文件即可使用。
//}//函数定义
/*如果编译器在遇到 daying() 的调用时还没有看到该函数的定义，会警告“函数未定义”。可以将函数定义放在调用之前，也可以在main（）前再次声明函数。*/

//标准输入输出函数
//int main()//int 表示函数的返回值类型；所有的c语言程序都要包括main（）函数；c语言规定main函数是程序的入口,表示执行的起点。
//{
	//打印字符串
	//printf("Hello Zejun\n");//字符串面值或常量是括在双引号""中，而字符常量是括在单引号''中;特别的，空格也是字符
	//字符串的结束标志是空字符'\0'(一个转义字符），它不占用内存空间，一般隐藏在字符串的末尾，无需特别处理。

	//计算字数据类型的字节数
	//printf("%zu\n", sizeof(char)); //sizeof()函数用于计算变量或数据类型的字节数，而strlen()函数用于计算字符串的长度。
	//printf("%zu\n", sizeof(int));//
	//printf("%zu\n", sizeof(short));
	//printf("%zu\n", sizeof(float));
	//printf("%zu\n", sizeof(double));
	//printf("%zu\n", sizeof(long));
	//printf("%zu\n", sizeof(long long));

	//调用函数
	//daying();

	//system("pause"); //system()用于运行系统命令，但仅限于Windows系统。pause函数表示让进程暂停直到信号出现
	//return 0;//return 0 可表示执行成功
//}

/*转义字符：将打印字符变为特殊含义的字符，如\n表示换行符、\t表示制表符、\b表示退格符、\r表示回车符等。如果要打印真正的反斜杠字符，则需要用两个反斜杠表示，如\\表示一个反斜杠。此外，转义字符算作一个字符，如\t的长度为1。*/

/*数据类型包括
char字符数据型
int整型数据型。字符本质上也是整型
short短整型数据型
float浮点型数据型
double双精度浮点型数据型
long长整型数据类型
long long更长的长整型数据型*/

//运算符演示
//int main()
//{
//	float a = 7 / 2.0;//除号两端都是整数，结果为整数，需要加.0来表示浮点数
//	printf("%.2f\n", a);//保留两位小数
//	int b = 10 % 3;//取模操作符的两端都必须是整数
//	printf("%d\n", b);
//	return 0;
//}

//运算符
//int main()//算术运算符（+、-、*、/、%）与赋值运算符（=、+=、-=、*=、/=、%=）
//{ 
	//int a = 0;//初始化
	//a = 10;//赋值
	//a += 10;//a = a + 10;
	//a -= 5;//a = a - 5;以此类推
	//int b = 0;
	//b = a++;//先赋值，再运算
	//printf("%d\n", a);
	//输出结果为b=10，a=15；a--同理
	//b = ++a;//先运算，再赋值
	//printf("%d\n", b);
	//printf("%d\n", a);
	//输出结果为b=16，a=16；--a同理
	//int c = (int) 3.14;//强制类型转换
	//printf("%d\n", c);//输出结果为3
//}

//关系运算符包括==、!=、<、>、<=、>=
//逻辑运算符包括&&（与）、||（或）、!（非）
//单目运算符包括++（自增）、--（自减）、+（正号）、-（负号）、*（指针）、&（取地址）、sizeof（取字节数）
//条件运算符也称为三目运算符，即条件表达式 ?  : ，它根据条件表达式的值（真或假）来决定表达式的值。
/*int main()
{
	int a = 0;
	int b = 0;
	int c = 0;
	scanf("%d%d", &a, &b);
	c = a > b ? a : b;//按a和b的顺序填表达式就行了；可用于比较两个数的大小
	printf("%d\n", c);
	//逗号表达式，即将多个表达式用逗号隔开，特点是从左到右计算，并返回最后一个表达式的值。
	int d = (c = a + b, b = c + a, b + c);
	printf("%d\n", d);
}*/
/*3) 条件运算符的嵌套：
int max = (a > b ? a : (b > c ? b : c));在这个例子中，条件运算符的嵌套从右到左进行评估。首先评估 b > c，如果这个条件为真，则返回 b，否则返回 c。然后再将得到的结果与 a 进行比较，最终得到 max 的值。即先运算最里层的条件表达式。*/

//&&运算符：左右两边的表达式都为真，则结果为真；否则结果为假。即布尔逻辑中的and运算。
//||运算符：左右两边的表达式有一个为真，则结果为真；否则结果为假。即布尔逻辑中的or运算。
//!运算符：取反，即表达式为真则结果为假，表达式为假则结果为真。即布尔逻辑中的not运算。
//?:运算符：条件运算符，即if-else语句的简化形式。

/*函数：
1.维基百科的定义为：子程序，是一个大型程序中的某部分代码，由一个或者多个语句块组成。它负责完成特定的功能，而且相较于其他代码，具备独立性
2.一般会有输入参数并有返回值，提高对过程的封装的细节的隐藏，这些代码通常被集成软件库
3.函数分为库函数和自定义函数
4.函数的实参（实际参数）是指在函数调用时传递给函数的具体值或变量。实参可以是常量、变量、表达式或其他函数的返回值。当函数被调用时，实参的值会被传递给相应的形参（形式参数），帮助函数完成其任务
5.形参只有在函数调用时才实例化（分配内存单元），当函数结束之后就自动销毁了。因此形参只在函数内有效*/

//使用指针可以在函数中修改实参的值。如：
//void swap(int *x, int *y)
//{
//	int temp = *x;
//	*x = *y;
//	*y = temp;
//}
//int main()
//{
//	int a = 10, b = 20;
//	printf("Before swap: a = %d, b = %d\n", a, b);
//	swap(&a, &b);//调用时要用&传递地址，告诉外部函数要访问哪里。
//	printf("After swap: a = %d, b = %d\n", a, b);
//	return 0;
//}

/*函数调用分为两种
1.传值调用：在传值调用的过程中，形参只是局部变量，其初值直接使用函数括号内实参的值，运行时占另外的空间，不对实参造成影响
2.传址调用：在传址调用的过程中，形参和实参占用同一内存单元，因此在函数内对形参的修改会影响实参的值，使得函数内部可以直接操作函数外部的变量*/

#include <string.h>//string.h中提供了一些字符串处理函数，如strcpy()，strcmp(),strlen()等。
//不使用临时变量，计算字符长度。解释：
//int my_strlen(char *str)//用指针接收地址；也可以写成数组的形式，如str[]。
//{
//	int count = 0;//为了实现某个功能（比如这里的计数）而创建，用完就销毁的变量（局部变量），称为临时变量
//	while (*str != '\0')
//	{
//		count++;
//		str++;//直接使用++找下一个字符。注意，是str而不是*str。
//	}
//	return count;
//}
//实现：
//int my_strlen(char *str)
//{
//	if (*str != '\0')
//	{
//		return 1 + my_strlen(str + 1);//参数里不能写str++。使用str + 1是正确的做法，因为它只是计算出下一个字符的地址，而不改变str指针本身。这样，str在每次递归调用中仍然指向原始字符串的起始地址。
//	}
//	else
//		return 0;
//}
//int main()
//{
//  //printf("%d\n", my_strlen("abc"));
//	char arr[4] = "abc";
//	printf("%d\n", my_strlen(arr));//字符串和数组的元素都是连续存放的，因此它们传参都是传首元素的地址，通过这个地址就可以访问到首元素及其后面的各个元素。
//	return 0;
//}

//最好能有一个自己的代码库，这样想要实现什么相似的功能直接复制粘贴就可以了。

//链式访问：把一个函数的返回值作为另一个函数的参数。


//递归函数：1.要有可以结束递归的限制条件 2.每次执行之后越来越接近这个限制条件