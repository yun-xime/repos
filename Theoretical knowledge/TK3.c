#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <windows.h>


/*调试与debug*/
//数组越界与覆盖
//栈区的使用习惯是先使用高地址处的空间，然后再使用低地址处的空间
//数组随着下标增长，地址由低到高变化
//两者的地址空间是相邻的，所以数组的越界与覆盖问题也就随之而来。
//在一些编译器中，这种错误不会报出来，可以通过调试器来查看。如：a[i] = 0, i > n, 数组a的长度为n,调试时取&a[i],&i,发现两者的地址相同，即修改a[i]的值，也会影响到i的值。
//(在本编译器中会直接报错，提示数组越界)
// 
//int main()
//{
//    int a[5] = { 1,2,3,4,5 };
//    int i = 5;
//    a[i] = 0; //数组越界
//    return 0;
//}  

/*优秀的代码：
1.代码在各平台上都能正常运行（即可移植性强）
2.代码易读易懂，命名规范，注释清晰
3.可维护性强，修改方便，易于扩展
4.文档齐全*/

//void strcpy(char* dst, const char* src)//const修饰src，表示src指向的字符串内容不可修改（起到保护作用），避免写代码的时候脑子一昏把要复制的数组和要覆盖的数组搞混。
//{
//    while (*src != '\0')
//    {
//        *dst = *src;
//        dst++;
//        src++;
//    }
//    *dst = '\0';
//}

//int main()
//{
//	const int n = 5;
//	/*int* p = &n;
//	*p = 10;*/ //可以用指针修改变量的值
//
//	//1.
//	const int* p = &n;
//	/**p = 10; *///报错。意思是指针p指向的地址不能修改，但指针本身可以修改。
//
//	//如：
//	int num = 2233;
//	//*p = &num;//error
//	p = &num; //right
//
//	//2.
//	int* const q = &num;
//	*q = 100; //right
//	//q = &num; //error。情况与1.相反。
//
//	return 0;
//}

/*编程常见错误：
1.编译型错误（语法错误）
2.链接型错误（出现在链接期间）-（找不到符号：1.未定义的函数 2.未定义的变量 3.重复定义 4.函数调用顺序错误 5.库文件缺失 6.库文件版本不匹配 7.库文件编译错误）
3.运行时错误（出现在运行期间）-（栈溢出 1.数组越界 2.除零错误 3.内存泄漏 4.指针错误 5.数据类型转换错误 6.系统调用失败 7.其他运行时错误）*/


/*数据存储*/
/*大小端：
大端：低地址存高位，高地址存低位（即低地址在前，高地址在后字节排布顺序和人的读写顺序相同）。特点：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小。
在早期的网络协议设计中，例如TCP/IP协议族，选择了大端作为默认字节序，这一决策逐渐演变为一种规范，很多现代网络协议仍然沿用这一标准。
小端：与大端相反。特点：1.强制转换数据时不需要调整字节内容；2.当CPU进行数值运算时，数据可以从低位开始依次读取，直至读取到高位字节，这样在内存访问时可以顺序进行，从而提高了缓存命中率和访问效率。
大小端有各自的优缺点，在不同的系统平台上，需要根据具体的应用场景选择适合的字节序。*/
//判断大小端方式：
//bool IsBigEndian()
//{
//    short a = 0x1234;
//    char b = *(char*)&a;
//    if (0x12 == b)
//    {
//        return true;
//    }
//
//    return false;
//}

//无符号与有符号：
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("char:%d\n", a);
//	printf("signed char:%d\n", b);//a和b的二进制位都是11111111。
//	printf("unsigned char:%d\n", c);//unsigned char表示无符号字符，范围是0到255。
//	//当将 - 1赋给c时， - 1会被转换为无符号数。在内存中，它的二进制表示仍然是11111111，但是在无符号解释下，它的值为255。
//	return 0;
//}

//char 转换为unsigned int：
//int  main()
//{
//	char a = -128;
//	printf("%d\n", a);//-128 的补码表示为 10000000
//	printf("%u\n", a);//在使用 %u 输出 a 时，printf 函数会将 char 类型的 a 视为无符号整数（unsigned int）。在这种情况下，-128 的二进制补码 10000000 被解释为一个无符号数。
//	return 0;
//}
//由于 char 类型占用 1 个字节，而无符号整数 unsigned int 通常占用 4 个字节（32 位），因此这个 char 的值会被扩展到 32 位。在这之后，前面的位被填充为 1，因为 char 是负数的补码表示。
// 最终得到11111111111111111111111110000000，即4294967168。
// (另：对于 10000000，其无符号的值可以通过以下计算得出：
//(2^0 * 0) + (2^1 * 0) + (2^2 * 0) + (2^3 * 0) + (2^4 * 0) + (2^5 * 0) + (2^6 * 0) + (2^7 * 1) = 128
// 则a= 2^32 - 128 = 4294967296 - 128 = 4294967168 )

//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%d ", i);
//		Sleep(1000);
//	}
//}
//for 循环的条件是 i >= 0，但是 i 的类型是 unsigned int，它只能表示非负值
// 当 i 减到 0 时，下一次 i-- 将导致 i 变为一个非常大的数（4294967295），因此 i >= 0 始终为真，造成无限循环。

//-1 的二进制表示为 11111111，它的补码表示为 11111111。