#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
//请你打印一个九九乘法表
//int main()
//{
//    int i, j;
//    for (i = 1; i <= 9; i++)
//    {
//        for (j = 1; j <= i; j++)
//        {
//            printf("%dx%d=%2d\t", j, i, i * j);
//        }
//        printf("\n");
//    }
//    return 0;
//}

//读输入
//给你一个3字符的字符串S，它是由[1,9]内的整数a，b及字符x按照axb顺序排列得到的。请你计算a和b的乘积。
// int main()
//{
//    int a, b;
//    scanf("%d x %d", &a, &b);//确保输入符合“axb”的格式
//    printf("%d\n", a * b);
//    return 0;
//}

//计算n的阶乘：1 * 2 * 3 * 4 *... * n = n!
//int main()
//{
//	int i = 1;
//	int n = 0;
//	int ret = 1;
//	scanf("%d", &n);
//	for (i = 1; i <= n; i++)
//	{
//		ret *= i;//与ret = ret * i 等价；把每次执行得到的i的值放到ret变量中，并累乘起来。
//	}
//	printf("%d\n", ret);
//	return 0;
//}
//运算过程：1.ret 与 i 相乘得1*1=1，并赋值给 ret存储起来，i++；2.ret 与 i 相乘得1*2=2，，i++；3.ret 与 i 相乘得1*2*3=6，i++；...；最后得到n的阶乘。
//递归算法可以更简洁地处理这个过程。
//int Fact(int n)
//{
//	int ret = n;
//	if (n > 1)
//	{
//		ret*=Fact(n - 1);
//	}
//	return ret;
//}//递归函数不能定义为内联函数。复杂函数：如果函数里有很多复杂的代码和逻辑，定义成内联函数会导致代码变得很长，增加可执行文件的大小，并且可能降低执行效率。 递归函数：递归函数是自己调用自己，定义成内联函数会导致无限展开，编译器无法正确处理。
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	printf("%d\n", Fact(n));
//	return 0;
//}

// //计算1！+ 2！+ 3！+ ... + 10!
//int main()
//{
//	int i = 1;
//	int ret = 0;
//	for (i = 1; i <= 10; i++)
//	{
//		int j = 1;
//		int f = 1;
//		for (j = 1; j <= i; j++)
//		{
//			f *= j;
//		}
//		ret += f;//把得到的阶乘放到ret变量中，并累加起来。
//	}
//	printf("%d\n", ret);
//	return 0;
//}


//循环
//地震的震级是地震释放的能量的对数比。已知每次震级增加1，能量就会增加大约32倍。在这里，我们假设每次震级增加1时，能量会准确地增加32倍。在这种情况下，震级为A的地震的能量是震级为B的地震的多少倍？
//约束条件：3<=B<=A<=9,且A和B均为整数,使用scanf函数和循环语句。
//int main()
//{
//	int A, B;
//	scanf("%d %d", &A, &B);
//	long long energy = 1;
//	int i;
//	for (i = B; i <A; i++)//循环变量 i 从 B 开始，每次循环 i 增加 1，直到 i 不再小于 A。这个循环的作用是计算从震级 B 到震级 A - 1 每增加一个震级，能量都要乘以 32。
//
//	{
//		energy *= 32;
//	}
//	printf("%lld\n",energy);
//	return 0;
//}
//不能使用（A-B)*32，因为题目所需要的是一个等比数列，而不是等差数列。

//在 C 语言中可以使用 long long 类型以避免溢出
// 现在需要采购一些苹果，每名同学都可以分到固定数量的苹果，并且已经知道了同学的数量，请问需要采购多少个苹果？
//
//输入格式
//输入两个不超过10^9的正整数，分别表示每人分到的数量和同学的人数。
//
//输出格式
//一个整数，表示答案。保证输入和答案都在 int 范围内的非负整数。
//int main()
//{
//	long long a = 0;
//	long long  b = 0;
//	scanf("%lld %lld", &a, &b);
//	printf("%lld\n", a * b);
//	return 0;
//}

//多组样例
//给你N对整数，(A1,B1),(A2,B2),...,(AN,BN)。对于每个i=1,2,...,N，输出Ai+Bi。
//约束条件：输出N行。对于i=1,2,...,N，第N行应包含Ai+Bi。1<=N<=1000,Ai大于等于-10^9,Bi小于等于10^9。
//#define MAX_N 1000//定义了一个常量MAX_N，其值为1000。这个常量用于限制数组的大小，即可以输入的整数对的最大数量为1000。
//int main()
//{
//    int N;
//    long long A[MAX_N], B[MAX_N];//声明了两个数组A和B，每个数组最大可存储MAX_N（即1000）个long long类型的数字。这两数组分别用于保存输入的两个整数。
//    scanf("%d", &N);//使用scanf函数从标准输入中读取一个整数，并将其存入变量N。这个值表示后续将要输入的整数对的数量。
//    for (int i = 0; i < N; i++)//循环变量i从0开始，每次循环i增加1，直到i不再小于N。这个循环的作用是读取N个整数对，并将其存入数组A和B。
//    {
//        scanf("%lld %lld", &A[i], &B[i]);//使用scanf函数从标准输入中读取两个整数，并将其存入数组A和B的第i个元素。
//    }
//    for (int i = 0; i < N; i++)//循环变量i从0开始，每次循环i增加1，直到i不再小于N。这个循环的作用是输出数组A和B的第i个元素之和。
//    {
//        printf("%lld\n", A[i] + B[i]);
//    }
//    return 0;
//}

//打印图案
//int main() {
//    printf("                ********\n");
//    printf("               ************\n");
//    printf("               ####....#.\n");
//    printf("             #..###.....##....\n");
//    printf("             ###.......######              ###            ###\n");
//    printf("                ...........               #...#          #...#\n");
//    printf("               ##*#######                 #.#.#          #.#.#\n");
//    printf("            ####*******######             #.#.#          #.#.#\n");
//    printf("           ...#***.****.*###....          #...#          #...#\n");
//    printf("           ....**********##.....           ###            ###\n");
//    printf("           ....****    *****....\n");
//    printf("             ####        ####\n");
//    printf("           ######        ######\n");
//    printf("##############################################################\n");
//    printf("#...#......#.##...#......#.##...#......#.##------------------#\n");
//    printf("###########################################------------------#\n");
//    printf("#..#....#....##..#....#....##..#....#....#####################\n");
//    printf("##########################################    #----------#\n");
//    printf("#.....#......##.....#......##.....#......#    #----------#\n");
//    printf("##########################################    #----------#\n");
//    printf("#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n");
//    printf("##########################################    ############\n");
//
//    return 0;
//}
