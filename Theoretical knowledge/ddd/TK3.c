#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
//#include <stdlib.h>
//#include <stdbool.h>
//#include <string.h>
//#include <time.h>
//#include <windows.h>


/*调试与debug*/
//数组越界与覆盖
//栈区的使用习惯是先使用高地址处的空间，然后再使用低地址处的空间
//数组随着下标增长，地址由低到高变化
//两者的地址空间是相邻的，所以数组的越界与覆盖问题也就随之而来。
//在一些编译器中，这种错误不会报出来，可以通过调试器来查看。如：a[i] = 0, i > n, 数组a的长度为n,调试时取&a[i],&i,发现两者的地址相同，即修改a[i]的值，也会影响到i的值。
//(在本编译器中会直接报错，提示数组越界)
// 
//int main()
//{
//    int a[5] = { 1,2,3,4,5 };
//    int i = 5;
//    a[i] = 0; //数组越界
//    return 0;
//}  

/*优秀的代码：
1.代码在各平台上都能正常运行（即可移植性强）
2.代码易读易懂，命名规范，注释清晰
3.可维护性强，修改方便，易于扩展
4.文档齐全*/

//void strcpy(char* dst, const char* src)//const修饰src，表示src指向的字符串内容不可修改（起到保护作用），避免写代码的时候脑子一昏把要复制的数组和要覆盖的数组搞混。
//{
//    while (*src != '\0')
//    {
//        *dst = *src;
//        dst++;
//        src++;
//    }
//    *dst = '\0';
//}

//定义一个指针变量p，则代码中*p表示指针指向的地址的值，p即指针变量本身。
//int main()
//{
//	const int n = 5;
//	/*int* p = &n;
//	*p = 10;*/ //可以用指针修改变量的值
//
//	1.
//	const int* p = &n;
//	/* *p = 10;  *///报错。意思是指针p指向的地址不能修改，但指针本身可以修改。
//
//	如：
//	int num = 2233;
//	*p = &num;//error
//	p = &num; //right
//
//	2.
//	int* const q = &num;
//	*q = 100; //right
//	q = &num; //error。情况与1.相反。
//
//	return 0;
//}

/*编程常见错误：
1.编译型错误（语法错误）
2.链接型错误（出现在链接期间）-（找不到符号：1.未定义的函数 2.未定义的变量 3.重复定义 4.函数调用顺序错误 5.库文件缺失 6.库文件版本不匹配 7.库文件编译错误）
3.运行时错误（出现在运行期间）-（栈溢出 1.数组越界 2.除零错误 3.内存泄漏 4.指针错误 5.数据类型转换错误 6.系统调用失败 7.其他运行时错误）*/


/*数据存储*/
//大小端：
/*大端：低地址存高位，高地址存低位（即低地址在前，高地址在后字节排布顺序和人的读写顺序相同）。特点：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小。
在早期的网络协议设计中，例如TCP/IP协议族，选择了大端作为默认字节序，这一决策逐渐演变为一种规范，很多现代网络协议仍然沿用这一标准。*/
/*小端：与大端相反。特点：1.强制转换数据时不需要调整字节内容（因为截断是截取低位）；
2.当CPU进行数值运算时，数据可以从低位开始依次读取，直至读取到高位字节，这样在内存访问时可以顺序进行，从而提高了缓存命中率和访问效率。*/
//大小端有各自的优缺点，在不同的系统平台上，需要根据具体的应用场景选择适合的字节序。
//判断大小端方式：
//bool IsBigEndian()
//{
//    short a = 0x1234;
//    char b = *(char*)&a;
//    if (0x12 == b)
//    {
//        return true;
//    }
//
//    return false;
//}

//整型的表示范围在limits.h中定义。
//无符号与有符号：
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("char:%d\n", a);
//	printf("signed char:%d\n", b);//a和b的二进制位都是11111111。
//	printf("unsigned char:%d\n", c);//unsigned char表示无符号字符，范围是0到255。
//	//当将 - 1赋给c时， - 1会被转换为无符号数。在内存中，它的二进制表示仍然是11111111，但是在无符号解释下，它的值为255。
//	return 0;
//}

//char 转换为unsigned int：
//int  main()
//{
//	char a = -128;
//	printf("%d\n", a);//-128 的补码表示为 10000000
//	printf("%u\n", a);//在使用 %u 输出 a 时，printf 函数会将 char 类型的 a 视为无符号整数（unsigned int）。在这种情况下，-128 的二进制补码 10000000 被解释为一个无符号数。
//	return 0;
//}
//由于 char 类型占用 1 个字节，而无符号整数 unsigned int 通常占用 4 个字节（32 位），因此这个 char 的值会被扩展到 32 位。在这之后，前面的位被填充为 1，因为 char 是负数的补码表示。
// 最终得到11111111111111111111111110000000，即4294967168。
// (另：对于 10000000，其无符号的值可以通过以下计算得出：
//(2^0 * 0) + (2^1 * 0) + (2^2 * 0) + (2^3 * 0) + (2^4 * 0) + (2^5 * 0) + (2^6 * 0) + (2^7 * 1) = 128
// 则a= 2^32 - 128 = 4294967296 - 128 = 4294967168 )

//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%d ", i);
//		Sleep(1000);
//	}
//}
//for 循环的条件是 i >= 0，但是 i 的类型是 unsigned int，它只能表示非负值
// 当 i 减到 0 时，下一次 i-- 将导致 i 变为一个非常大的数（4294967295），因此 i >= 0 始终为真，造成无限循环。
//同样死循环：
//int main()
//{
//	for (char i = 0; i <= 255; i++)
//	{
//		printf("%d ", i);
//	}
//	return 0;
//}

//-1 的二进制表示为 11111111，它的补码表示为 11111111。

//int main()
//{
//	char a[1000];
//	for (int i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%zu\n", strlen(a));//strlen函数计算字符串的长度，返回值类型size_t(注意，它也是个无符号整数)，要用zu来打印。
//	return 0;
//}
//strlen读取到\0时停止，而a[]={-1,-2,...,-128,127,126,125,...,3,2,1,0},故strlen返回（128+127）= 255。需要站在机器角度（二进制位）来理解。

//浮点型在内存中的存储：
//1E10即1.0的10次方
//浮点数的表示范围在float.h中定义。
//在浮点数的处理过程中，可能会遇到精度损失的问题，一些常见的小数在二进制中不能被精确表示，这会导致在计算如0.1 + 0.2等操作时结果不如预期，比如得到0.30000000000000004而不是0.3
//解决方法：
//1.使用更高精度的浮点数类型，如double或long double。
//2.使用科学记数法表示浮点数，如1.23e-45。
//3.使用字符串表示浮点数，如"3.14159"。
//4.使用专业的数学库或函数库进行浮点数运算。

/*根据国际标准IEEE(电气和电子工程师协会）规定，任意一个二进制数可以表示成：
（-1）^S * M * 2^E
其中（-1）^S表示符号位，S为0表示正数，S为1表示负数
M表示有效数字，大于等于1，小于2
2^E表示指数位。对于32位浮点数，E的存储值加上了127作为偏移量（bias)，因此实际的指数需要减去127来得到真实的指数值。E是无符号整数。*/
//例：5.0f -> 101.0 -> 1.01 * 2^2(2^2表示小数点移动了2个二进制位)->(-1)^0 * 1.01 * 2^2
/*9.5f:
1.整数部分为1001
2.小数部分0.5的二进制表示：0.5 * 2 = 1.0（取整部分）
3.得1.0011 * 2^3
4.将浮点数拆分为符号位、指数位和尾数位（根据IEEE 754标准）：
符号位：9.5是正数，符号位为0。
指数位：真实指数为3，偏置为127，因此存储的指数为3+127=130，130的二进制表示为10000010。
尾数位（有效数字）：去掉前面的1，结果是0011，后面补零到23位，所以尾数为0011000000000000000000000。
5.最终得到01000001000110000000000000000000
9.6f无法精确表示。*/
//特殊情况：1.E全为1，M全为0，表示无穷大。2.E全为0，M全为0，表示NaN（Not a Number）。3.E全为0，M非0，表示0。4.E全为1，M非0，表示无穷小。

